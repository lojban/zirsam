; The amazing, the incredible...
;
; ▛▀▘   ▐          ▌         ▛▀▖▙ ▌▛▀▘
; ▙▄ ▚▗▘▜▀ ▞▀▖▛▀▖▞▀▌▄▄▖▞▀▖▄▄▖▙▄▘▌▌▌▙▄
; ▌  ▗▚ ▐ ▖▛▀ ▌ ▌▌ ▌   ▌ ▌   ▌ ▌▌▝▌▌
; ▀▀▘▘ ▘ ▀ ▝▀▘▘ ▘▝▀▘   ▝▀    ▀▀ ▘ ▘▘
;
;                       /brought to you by Trader Joe's/
;
; These rules are appended onto the end of lojban.bnf when it is built
; It would be a good idea to prepend additions with "x-"


; The following rules are from lojban.bnf, but modified to integrate with the thaumatology pre-processor
lerfu-word =
    BY
    | BU ;Originally any-word BU
    | LAU lerfu-word
    | TEI lerfu-string FOI  

tanru-unit-2 =
    BRIVLA #
    | GOhA [RAhO] #
    | KE # selbri-3 /KEhE#/
    | ME # sumti /MEhU#/ [MOI #]
    | (number | lerfu-string) MOI #
    | NUhA # mex-operator
    | SE # tanru-unit-2
    | JAI # [tag] tanru-unit-2
;| any-word (ZEI any-word) ...  ; Preprocessor converts ZEI to BRIVLA, so not needed
    | NAhE # tanru-unit-2
    | NU [NAI] # [joik-jek NU [NAI] #] ... subsentence /KEI#/

lerfu-word =
    BY
    | BU ;originally any-word BU
    | LAU lerfu-word
    | TEI lerfu-string FOI

;Full of issues
sumti-6 =
    (LAhE # | NAhE BO #) [relative-clauses] sumti /LUhU#/
    | KOhA #
    | lerfu-string /BOI#/
    | LA # [relative-clauses] CMENE ... # 
    | (LA | LE) # sumti-tail /KU#/
    | LI # mex /LOhO#/
    | ZO # ; ZO any-word #
    | LU text /LIhU#/
    | LOhU LEhU # ;originally "LOhU any-word ... LEhU #". Thaumatology keeps the LEhU
    | ZOI # ; originally "ZOI any-word anything any-word #"




x-parse-root =
  ;;;; This is the default starting point
  ;;;; This should refer to a single rule.
  ;;;; (An old bug, haven't tested recently TODO)
  ;sentence
  text
  ;x-test

x-parse-sentence =
  [I] sentence

x-test =
  ;;;; All my BNF tests
  ;x-test-issue-1
  ;x-test-issue-2
  ;x-test-issue-3
  ;x-test-cat
  ;x-test-cat-2
  x-test-undermatch
  ;x-test-xor
  ;x-test-and
  ;x-test-optional-1
  ;x-test-optional-2
  ;x-test-optional-3
  ;x-test-elide

x-test-issue-1 =
  LA CMENE ...
  | LA SELBRI

x-test-issue-2 =
    a [b] ...

x-test-issue-3 =
  x-test-issue-3-bit-1 KOhA

x-test-issue-3-bit-1 =
    LAhE x-test-issue-3-bit-2 /LUhU#/

x-test-issue-3-bit-2 =
  KOhA
  | x-test-issue-3-bit-1

x-test-undermatch = x-short | x-long
x-short = PA
x-long = [PA] LE SELBRI

a =
  A
b =
  CMENE



x-test-cat =
  ;coi bab
  a b

x-test-cat-2 =
  a b ...

x-test-xor =
  ;coi
  ;bab
  a | b

x-test-and =
  ;coi bab; bab; coi
  a & b

x-test-optional-1 =
  a [b]

x-test-optional-2 =
  [b] a

x-test-optional-3 =
  a [x-test-optional-3-bit] a
x-test-optional-3-bit = [b]

x-test-elide =
  ;lo broda broda selbri; lo broda broda cu selbri; lo broda pa; ko'a selbri; ko'a pa
  x-test-elide-bit-1 [x-test-elide-bit-2]
  ;Does it actually work? No. Idea.

x-test-elide-bit-1 =
  (LE SELBRI ...) | KOhA

x-test-elide-bit-2 =
  (/CU/ SELBRI) | PA

x-inefficiency-example =
  a b c
;TODO: Stored as "Concat(Concat(a, b), c)". It would be better to be done as Concat(a, Concat(b, c))


;;;;Non-Formal Rules Checklist:
;       word: just uses any-word, thaumatology folds the BAhE into it
;       any-word: CHECK
;       anything: CHECK
;       null: Uh, not present at all. Erased words are taken care of by thaumatology.
;       ui: I guess it's okay
;
;               The following rules are non-formal:
;word =
;   [BAhE] any-word [indicators]
;any-word =
;   “any single word (no compound cmavo)”
;anything =
;   “any text at all, whether Lojban or not” 
;null =
;   any-word SI
;    | utterance SA
;    | text SU
